
var between     = require('between')
var Scuttlebutt = require('scuttlebutt')
var inherits    = require('util').inherits
var filter      = require('scuttlebutt/util').filter

inherits(RArray, Scuttlebutt)

module.exports = RArray

function fuzz () {
  return Math.random().toString().substring(2, 5)
}

var DOEMIT = true, CHANGE = {}

function order (a, b) {
  //timestamp, then source
  return between.strord(a[1], b[1]) || between.strord(a[2], b[2])
}

function RArray () {
  if (!(this instanceof RArray)) return new RArray()
  Scuttlebutt.call(this)
  this.keys = []
  this.store = {}
  this._hist = {}
  this.length = 0
  if(arguments.length) {
    var self = this
    ;[].forEach.call(arguments, function (e) {
      self.push(e)
    })
  }
}

var A = RArray.prototype

A.last = function () {
  return this.keys[this.keys.length - 1]
}

A.first = function () {
  return this.keys[0]
}

A.insert = function (before, val, after) {  
  var key = between(before || between.lo, after || between.hi) + fuzz()
  this.set(key, val)
  return key
}

A.push = function (val) {
  var key = this.insert(this.last(), val)
}

A.unshift = function (val) {
  var key = this.insert(null, val, this.first())
}

A.indexOf = function (val) {
  for(var i in this.keys) {
    var key = this.keys[i]
    if(val === this.get(key)) return i
  }
  return null
}

A.indexOfKey = function (key) {
  return this.keys.indexOf(key)
}

A.toJSON = function () {
  var store = this.store
  var self = this
  return this.keys.map(function (key) {
    return self.get(key)
  })
}

A.set = function (key, val) {
  if('string' == typeof key) {
    if(val === null) return this.unset(key)
    if(null == this.store[key]) this.length ++
    this.store[key] = val
    if(!~this.keys.indexOf(key)) {
      this.keys.push(key)
      this.keys.sort()
    }
    CHANGE[key] = val
    DOEMIT && this._emit()
  }
}

A.get = function (key) {
  return this.store[key]
}

A.unset = function (key) {
  if('string' == typeof key) {
    if(null != this.store[key]) this.length --
    delete this.store[key]
    var i = this.keys.indexOf(key)
    if(!~i) return
    this.keys.splice(i, 1)    

    CHANGE[key] = null
    DOEMIT && this._emit()
  }
}

A.pop = function () {
  var l = this.last()
  var val = this.store[l]
  this.unset(l)
  return val
}

A.shift = function () {
  var f = this.first()
  var val = this.store[f]
  this.unset(f)
  return val
}

A._emit = function () {
  if(!DOEMIT) return
  this.localUpdate(CHANGE)
  CHANGE = {}
}

A.splice = function (i, d /*,...args*/) {
  var args = [].slice.call(arguments, 2)
  var j = 0, l = args.length

  DOEMIT = false

  if(d + i > this.keys.length)
    d = this.keys.length - i
  
  while(j < d) {
    if(j < l)
      this.set(this.keys[i+j], args[j]), j++
    else
      this.unset(this.keys[i+j]), d--
  }

  while(j < l)
    this.insert(this.keys[i+j-1], args[j], this.keys[i+j]), j++

  DOEMIT = true
  this._emit()
}

A.applyUpdate = function (update) {
  DOEMIT = false
  var change = update[0], old
  var apply = {}, ch = {}
  var old = {}
  for(var key in change) {
    if(!this._hist[key] || order(update, this._hist[key]) > 0)
      apply[key] = change[key]
  }
  //allow the user to see what the change is going to be.
  this.emit('preupdate', apply) 

  //apply the change...
  for(var key in apply) {
    var o = this._hist[key]
    o && (old[o[1]+':'+o[2]] = o) //ts:source
    this._hist[key] = update
    this.set(key, apply[key])
  }

  //check if old elements need to be removed.
  //may also want to keep old updates hanging around 
  //so the user can see recent history...
  for(var id in old) {
    var o = old[id][0], rm = true
    for(var key in o) {
      if(this._hist[key] === old[id]) rm = false
    }
    if(rm)
      this.emit('_remove', old[id])
  }
    
  DOEMIT = true
  CHANGE = {}
  this.emit('update', apply)
  return true
}


A.history = function (sources) {
  var h = []
  for (var key in this._hist) {
    var update = this._hist[key]
      if(!~h.indexOf(update) && filter(update, sources))
        h.push(update)
  }
  return h.sort(order)
}

A.forEach = function (fun) {
  return this.toJSON().forEach(fun)
}

A.filter = function (fun) {
  return this.toJSON().filter(fun)
}

A.map = function (fun) {
  return this.toJSON().map(fun)
}

A.reduce = function (fun, initial) {
  return this.toJSON().reduce(fun, initial)
}

//.length is a property, not a function.
